name: Release

on:
  push:
    tags:
      - "v*.*.*"
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g., 1.9.3)"
        required: true
        type: string
      dry_run:
        description: "Dry run (build only, no release)"
        required: false
        type: boolean
        default: true

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  # Extract version from tag or input
  prepare-release:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      version_name: ${{ steps.get_version.outputs.version_name }}
      dry_run: ${{ steps.get_version.outputs.dry_run }}
    steps:
      - name: Get version from tag or input
        id: get_version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
            DRY_RUN="${{ github.event.inputs.dry_run }}"
          else
            VERSION=${GITHUB_REF#refs/tags/v}
            DRY_RUN="false"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "version_name=v$VERSION" >> $GITHUB_OUTPUT
          echo "dry_run=$DRY_RUN" >> $GITHUB_OUTPUT
          echo "Release version: $VERSION (dry_run: $DRY_RUN)"

  # Update version in Cargo.toml files (skipped in dry-run)
  update-versions:
    name: Update Crate Versions
    runs-on: ubuntu-latest
    needs: prepare-release
    if: needs.prepare-release.outputs.dry_run != 'true'
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Setup Nix cache
        uses: DeterminateSystems/magic-nix-cache-action@main
        with:
          use-gha-cache: false
          use-flakehub: false

      - name: Install cargo-edit and update versions
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          echo "Updating all crates to version $VERSION"
          nix develop -c cargo install cargo-edit --locked
          nix develop -c cargo set-version --workspace $VERSION

          echo "Updated versions:"
          grep "^version" Cargo.toml
          grep "^version" crates/*/Cargo.toml

      - name: Commit version updates
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Cargo.toml Cargo.lock crates/*/Cargo.toml
          git commit -m "chore: bump version to ${{ needs.prepare-release.outputs.version }}" || echo "No changes to commit"
          git push origin HEAD:master || echo "No changes to push"

  # Build release binaries for x86_64 using Nix
  build-release-x86_64:
    name: Build Release (x86_64)
    runs-on: ubuntu-latest
    needs: prepare-release
    # For real releases, wait for version update; for dry-run, proceed immediately
    if: always() && needs.prepare-release.result == 'success'
    steps:
      - uses: actions/checkout@v4

      - name: Free up disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force || true
          sudo apt-get clean || true

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Setup Nix cache
        uses: DeterminateSystems/magic-nix-cache-action@main
        with:
          use-gha-cache: false
          use-flakehub: false

      - name: Build with Nix
        run: |
          nix build .#oracle --print-build-logs
          nix build .#daemon --print-build-logs -o result-daemon

      - name: Build with Cargo (for compatibility)
        run: |
          nix develop -c cargo build --release --locked --workspace
        env:
          RUSTFLAGS: "-C link-arg=-fuse-ld=lld"

      - name: Create release package
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          PKG_NAME="noaa-oracle-${VERSION}-x86_64-linux"

          mkdir -p "${PKG_NAME}/bin"
          mkdir -p "${PKG_NAME}/ui"
          mkdir -p "${PKG_NAME}/config"

          # Copy Nix-built binaries (preferred - fully static)
          cp result/bin/oracle "${PKG_NAME}/bin/"
          cp result-daemon/bin/daemon "${PKG_NAME}/bin/"

          # Copy UI
          cp -r ui/* "${PKG_NAME}/ui/"

          # Copy and rename config examples to usable defaults
          cp config/oracle.example.toml "${PKG_NAME}/config/oracle.toml"
          cp config/daemon.example.toml "${PKG_NAME}/config/daemon.toml"

          # Create setup script for first-time deployment
          cat > "${PKG_NAME}/setup.sh" << 'EOF'
          #!/bin/bash
          set -e
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          cd "$SCRIPT_DIR"

          echo "NOAA Oracle Setup"
          echo "================="

          # Create data directories
          echo "Creating data directories..."
          mkdir -p weather_data event_data logs data

          # Generate signing key
          if [ -f "oracle_private_key.pem" ]; then
              echo "WARNING: oracle_private_key.pem already exists!"
              echo "Skipping key generation. Delete the file manually if you want to regenerate."
          else
              echo "Generating oracle signing key..."
              openssl ecparam -genkey -name secp256k1 -out oracle_private_key.pem
              chmod 600 oracle_private_key.pem
              echo "Private key created: oracle_private_key.pem"
              echo ""
              echo "IMPORTANT: Back up this key securely! It is used for DLC attestations."
              echo "If lost, any events signed with this key cannot be attested."
          fi

          echo ""
          echo "Setup complete! You can now run:"
          echo "  ./run-oracle.sh  - Start the oracle server"
          echo "  ./run-daemon.sh  - Start the data fetching daemon"
          EOF
          chmod +x "${PKG_NAME}/setup.sh"

          # Create run script for oracle
          cat > "${PKG_NAME}/run-oracle.sh" << 'EOF'
          #!/bin/bash
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          cd "$SCRIPT_DIR"

          if [ ! -f "oracle_private_key.pem" ]; then
              echo "ERROR: oracle_private_key.pem not found!"
              echo "Run ./setup.sh first to generate the signing key."
              exit 1
          fi

          # Create data directories if missing
          mkdir -p weather_data event_data logs

          export RUST_LOG="${RUST_LOG:-info}"
          exec ./bin/oracle "$@"
          EOF
          chmod +x "${PKG_NAME}/run-oracle.sh"

          # Create run script for daemon
          cat > "${PKG_NAME}/run-daemon.sh" << 'EOF'
          #!/bin/bash
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          cd "$SCRIPT_DIR"

          mkdir -p data logs

          export RUST_LOG="${RUST_LOG:-info}"
          exec ./bin/daemon "$@"
          EOF
          chmod +x "${PKG_NAME}/run-daemon.sh"

          # Create README
          cat > "${PKG_NAME}/README.txt" << EOF
          NOAA Oracle v${VERSION}
          =======================

          Quick Start:
            1. Run ./setup.sh to initialize (creates directories and signing key)
            2. Run ./run-oracle.sh to start the oracle server (default port 9800)
            3. Run ./run-daemon.sh to start fetching NOAA weather data

          Configuration:
            - Edit config/oracle.toml for oracle settings
            - Edit config/daemon.toml for daemon settings

          Directories:
            - ui/           Browser UI files
            - config/       Configuration files
            - bin/          Binaries
            - weather_data/ Downloaded parquet files (created on first run)
            - event_data/   DLC event database (created on first run)

          Security:
            - oracle_private_key.pem is your signing key - BACK IT UP!
            - This key is used for DLC attestations and must be kept secure

          For more info: https://github.com/tee8z/noaa-oracle
          EOF

          # Create zip
          zip -r "${PKG_NAME}.zip" "${PKG_NAME}"

          # Also create separate tarballs for cargo-built binaries
          mkdir -p release
          mv "${PKG_NAME}.zip" release/

          # Cargo binaries tarball (for users who prefer dynamic linking)
          mkdir -p cargo-pkg/bin
          cp target/release/oracle cargo-pkg/bin/
          cp target/release/daemon cargo-pkg/bin/
          tar czf "release/noaa-oracle-${VERSION}-x86_64-linux-cargo.tar.gz" -C cargo-pkg .
          rm -rf cargo-pkg

          ls -lh release/

      - name: Upload release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-x86_64-linux
          path: release/*
          retention-days: 7

  # Build release binaries for ARM64 (aarch64) using Nix cross-compilation
  build-release-arm64:
    name: Build Release (ARM64)
    runs-on: ubuntu-latest
    needs: prepare-release
    # For real releases, wait for version update; for dry-run, proceed immediately
    if: always() && needs.prepare-release.result == 'success'
    steps:
      - uses: actions/checkout@v4

      - name: Free up disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force || true
          sudo apt-get clean || true

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main
        with:
          extra-conf: |
            extra-platforms = aarch64-linux

      - name: Setup Nix cache
        uses: DeterminateSystems/magic-nix-cache-action@main
        with:
          use-gha-cache: false
          use-flakehub: false

      - name: Install QEMU for ARM64 emulation
        run: |
          sudo apt-get update
          sudo apt-get install -y qemu-user-static binfmt-support
          sudo update-binfmts --enable qemu-aarch64

      - name: Build with Nix for ARM64
        run: |
          nix build .#packages.aarch64-linux.oracle --print-build-logs
          nix build .#packages.aarch64-linux.daemon --print-build-logs -o result-daemon

      - name: Create release package
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          PKG_NAME="noaa-oracle-${VERSION}-aarch64-linux"

          mkdir -p "${PKG_NAME}/bin"
          mkdir -p "${PKG_NAME}/ui"
          mkdir -p "${PKG_NAME}/config"

          # Copy Nix-built binaries
          cp result/bin/oracle "${PKG_NAME}/bin/"
          cp result-daemon/bin/daemon "${PKG_NAME}/bin/"

          # Copy UI
          cp -r ui/* "${PKG_NAME}/ui/"

          # Copy and rename config examples to usable defaults
          cp config/oracle.example.toml "${PKG_NAME}/config/oracle.toml"
          cp config/daemon.example.toml "${PKG_NAME}/config/daemon.toml"

          # Create setup script for first-time deployment
          cat > "${PKG_NAME}/setup.sh" << 'EOF'
          #!/bin/bash
          set -e
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          cd "$SCRIPT_DIR"

          echo "NOAA Oracle Setup"
          echo "================="

          # Create data directories
          echo "Creating data directories..."
          mkdir -p weather_data event_data logs data

          # Generate signing key
          if [ -f "oracle_private_key.pem" ]; then
              echo "WARNING: oracle_private_key.pem already exists!"
              echo "Skipping key generation. Delete the file manually if you want to regenerate."
          else
              echo "Generating oracle signing key..."
              openssl ecparam -genkey -name secp256k1 -out oracle_private_key.pem
              chmod 600 oracle_private_key.pem
              echo "Private key created: oracle_private_key.pem"
              echo ""
              echo "IMPORTANT: Back up this key securely! It is used for DLC attestations."
              echo "If lost, any events signed with this key cannot be attested."
          fi

          echo ""
          echo "Setup complete! You can now run:"
          echo "  ./run-oracle.sh  - Start the oracle server"
          echo "  ./run-daemon.sh  - Start the data fetching daemon"
          EOF
          chmod +x "${PKG_NAME}/setup.sh"

          # Create run script for oracle
          cat > "${PKG_NAME}/run-oracle.sh" << 'EOF'
          #!/bin/bash
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          cd "$SCRIPT_DIR"

          if [ ! -f "oracle_private_key.pem" ]; then
              echo "ERROR: oracle_private_key.pem not found!"
              echo "Run ./setup.sh first to generate the signing key."
              exit 1
          fi

          # Create data directories if missing
          mkdir -p weather_data event_data logs

          export RUST_LOG="${RUST_LOG:-info}"
          exec ./bin/oracle "$@"
          EOF
          chmod +x "${PKG_NAME}/run-oracle.sh"

          # Create run script for daemon
          cat > "${PKG_NAME}/run-daemon.sh" << 'EOF'
          #!/bin/bash
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          cd "$SCRIPT_DIR"

          mkdir -p data logs

          export RUST_LOG="${RUST_LOG:-info}"
          exec ./bin/daemon "$@"
          EOF
          chmod +x "${PKG_NAME}/run-daemon.sh"

          # Create README
          cat > "${PKG_NAME}/README.txt" << EOF
          NOAA Oracle v${VERSION} (ARM64/aarch64)
          =======================================

          Quick Start:
            1. Run ./setup.sh to initialize (creates directories and signing key)
            2. Run ./run-oracle.sh to start the oracle server (default port 9800)
            3. Run ./run-daemon.sh to start fetching NOAA weather data

          Configuration:
            - Edit config/oracle.toml for oracle settings
            - Edit config/daemon.toml for daemon settings

          Directories:
            - ui/           Browser UI files
            - config/       Configuration files
            - bin/          Binaries
            - weather_data/ Downloaded parquet files (created on first run)
            - event_data/   DLC event database (created on first run)

          Security:
            - oracle_private_key.pem is your signing key - BACK IT UP!
            - This key is used for DLC attestations and must be kept secure

          For more info: https://github.com/tee8z/noaa-oracle
          EOF

          # Create zip
          mkdir -p release
          zip -r "release/${PKG_NAME}.zip" "${PKG_NAME}"

          ls -lh release/

      - name: Upload release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-aarch64-linux
          path: release/*
          retention-days: 7

  # Create GitHub release (skipped in dry-run)
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [prepare-release, build-release-x86_64, build-release-arm64]
    if: needs.prepare-release.outputs.dry_run != 'true'
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Display structure of downloaded files
        run: ls -R artifacts

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          name: Release ${{ needs.prepare-release.outputs.version_name }}
          draft: false
          prerelease: false
          generate_release_notes: true
          files: |
            artifacts/**/*.zip
            artifacts/**/*.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Build and push Docker images to GHCR (x86_64)
  build-docker-images-amd64:
    name: Build Docker Images (amd64)
    runs-on: ubuntu-latest
    needs: [prepare-release]
    if: always() && needs.prepare-release.result == 'success'
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        include:
          - image: oracle
            nix_output: docker-oracle
          - image: daemon
            nix_output: docker-daemon
    steps:
      - uses: actions/checkout@v4

      - name: Free up disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force || true

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Setup Nix cache
        uses: DeterminateSystems/magic-nix-cache-action@main
        with:
          use-gha-cache: false
          use-flakehub: false

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build x86_64 image
        run: |
          nix build .#${{ matrix.nix_output }} --print-build-logs
          docker load < result
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          docker tag noaa-${{ matrix.image }}:latest ghcr.io/${REPO_LOWER}/${{ matrix.image }}:${{ needs.prepare-release.outputs.version }}-amd64
          docker tag noaa-${{ matrix.image }}:latest ghcr.io/${REPO_LOWER}/${{ matrix.image }}:latest-amd64

      - name: Push amd64 images
        if: needs.prepare-release.outputs.dry_run != 'true'
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          IMAGE="ghcr.io/${REPO_LOWER}/${{ matrix.image }}"

          docker push ${IMAGE}:${VERSION}-amd64
          docker push ${IMAGE}:latest-amd64

  # Build and push Docker images to GHCR (arm64)
  build-docker-images-arm64:
    name: Build Docker Images (arm64)
    runs-on: ubuntu-24.04-arm
    needs: [prepare-release]
    if: always() && needs.prepare-release.result == 'success'
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        include:
          - image: oracle
            nix_output: docker-oracle
          - image: daemon
            nix_output: docker-daemon
    steps:
      - uses: actions/checkout@v4

      - name: Free up disk space
        run: |
          sudo docker image prune --all --force || true

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Setup Nix cache
        uses: DeterminateSystems/magic-nix-cache-action@main
        with:
          use-gha-cache: false
          use-flakehub: false

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build arm64 image
        run: |
          nix build .#${{ matrix.nix_output }} --print-build-logs
          docker load < result
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          docker tag noaa-${{ matrix.image }}:latest ghcr.io/${REPO_LOWER}/${{ matrix.image }}:${{ needs.prepare-release.outputs.version }}-arm64
          docker tag noaa-${{ matrix.image }}:latest ghcr.io/${REPO_LOWER}/${{ matrix.image }}:latest-arm64

      - name: Push arm64 images
        if: needs.prepare-release.outputs.dry_run != 'true'
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          IMAGE="ghcr.io/${REPO_LOWER}/${{ matrix.image }}"

          docker push ${IMAGE}:${VERSION}-arm64
          docker push ${IMAGE}:latest-arm64

  # Create multi-arch manifests after both architectures are built
  create-docker-manifests:
    name: Create Docker Manifests
    runs-on: ubuntu-latest
    needs: [prepare-release, build-docker-images-amd64, build-docker-images-arm64]
    if: needs.prepare-release.outputs.dry_run != 'true'
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        image: [oracle, daemon]
    steps:
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-arch manifests
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          IMAGE="ghcr.io/${REPO_LOWER}/${{ matrix.image }}"

          # Create and push versioned manifest
          docker manifest create ${IMAGE}:${VERSION} \
            ${IMAGE}:${VERSION}-amd64 \
            ${IMAGE}:${VERSION}-arm64
          docker manifest push ${IMAGE}:${VERSION}

          # Create and push latest manifest
          docker manifest create ${IMAGE}:latest \
            ${IMAGE}:latest-amd64 \
            ${IMAGE}:latest-arm64
          docker manifest push ${IMAGE}:latest

          echo "Pushed multi-arch image: ${IMAGE}:${VERSION}"
